//---------------------------------------------------------------------------

#pragma hdrstop

#include "IdNameTable.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

bool IdNameTable::stringEqual(const char* a, const char* b) {
    if (a == b) return true;
    if (!a || !b) return false;
    while (*a && *b) {
        if (*a != *b) return false;
        a++;
        b++;
    }
    return *a == *b;
}

bool IdNameTable::stringLess(const char* a, const char* b) {
    if (!a) return true;
    if (!b) return false;
    while (*a && *b) {
        if (*a < *b) return true;
        if (*a > *b) return false;
        a++;
        b++;
    }
    return *a == 0 && *b != 0;
}

char* IdNameTable::copyString(const char* src) {
    if (!src) return 0;

    int len = 0;
    while (src[len]) len++;

    char* dest = new char[len + 1];

    for (int i = 0; i < len; i++) {
        dest[i] = src[i];
    }
    dest[len] = '\0';

    return dest;
}

IdNameTable::IdNameTable(int initialCapacity) {
    capacity = initialCapacity > 0 ? initialCapacity : 1;
    count = 0;
    table = new IdName*[capacity];
    for (int i = 0; i < capacity; i++) {
        table[i] = 0;
    }
    isSortedById = true;
    isSortedByName = true;
}

IdNameTable::~IdNameTable() {
    for (int i = 0; i < count; i++) {
        delete table[i];
    }
    delete[] table;
}

void IdNameTable::add(int id, const char* name) {
    if (count >= capacity) {
        int newCapacity = capacity * 2;
        IdName** newTable = new IdName*[newCapacity];
        for (int i = 0; i < count; i++) {
            newTable[i] = table[i];
        }
        for (int i = count; i < newCapacity; i++) {
            newTable[i] = 0;
        }
        delete[] table;
        table = newTable;
        capacity = newCapacity;
    }

    IdName* newElement = new IdName;
    newElement->id = id;
    newElement->name = name;

    table[count] = newElement;
    count++;

    isSortedById = false;
    isSortedByName = false;
}

bool IdNameTable::remove(int id) {
    for (int i = 0; i < count; i++) {
        if (table[i]->id == id) {
            delete table[i];
            for (int j = i; j < count - 1; j++) {
                table[j] = table[j + 1];
            }
            count--;
            isSortedById = false;
            isSortedByName = false;
            return true;
        }
    }
    return false;
}

void IdNameTable::clear() {
    for (int i = 0; i < count; i++) {
        delete table[i];
    }
    count = 0;
    isSortedById = true;
    isSortedByName = true;
}

int IdNameTable::partitionById(int left, int right) {
    int mid = left + (right - left) / 2;

    if (table[mid]->id < table[left]->id) {
        IdName* temp = table[left];
        table[left] = table[mid];
        table[mid] = temp;
    }
    if (table[right]->id < table[left]->id) {
        IdName* temp = table[left];
        table[left] = table[right];
        table[right] = temp;
    }
    if (table[right]->id < table[mid]->id) {
        IdName* temp = table[mid];
        table[mid] = table[right];
        table[right] = temp;
    }

    IdName* pivot = table[mid];
    int pivotId = pivot->id;
    table[mid] = table[right];
    table[right] = pivot;

    int i = left - 1;
    for (int j = left; j < right; j++) {
        if (table[j]->id <= pivotId) {
            i++;
            IdName* temp = table[i];
            table[i] = table[j];
            table[j] = temp;
        }
    }

    table[right] = table[i + 1];
    table[i + 1] = pivot;

    return i + 1;
}

void IdNameTable::quickSortById(int left, int right) {
    if (right - left < 10) {
        for (int i = left + 1; i <= right; i++) {
            IdName* key = table[i];
            int j = i - 1;
            while (j >= left && table[j]->id > key->id) {
                table[j + 1] = table[j];
                j--;
            }
            table[j + 1] = key;
        }
        return;
    }

    if (left < right) {
        int pivotIndex = partitionById(left, right);
        quickSortById(left, pivotIndex - 1);
        quickSortById(pivotIndex + 1, right);
    }
}

void IdNameTable::sortById() {
    if (count <= 1) {
        isSortedById = true;
        return;
    }
    quickSortById(0, count - 1);
    isSortedById = true;
    isSortedByName = false;
}

int IdNameTable::partitionByName(int left, int right) {
    int mid = left + (right - left) / 2;

    if (stringLess(table[mid]->name, table[left]->name)) {
        IdName* temp = table[left];
        table[left] = table[mid];
        table[mid] = temp;
    }
    if (stringLess(table[right]->name, table[left]->name)) {
        IdName* temp = table[left];
        table[left] = table[right];
        table[right] = temp;
    }
    if (stringLess(table[right]->name, table[mid]->name)) {
        IdName* temp = table[mid];
        table[mid] = table[right];
        table[right] = temp;
    }

    IdName* pivot = table[mid];
    const char* pivotName = pivot->name;
    table[mid] = table[right];
    table[right] = pivot;

    int i = left - 1;
    for (int j = left; j < right; j++) {
        if (stringLess(table[j]->name, pivotName) || stringEqual(table[j]->name, pivotName)) {
            i++;
            IdName* temp = table[i];
            table[i] = table[j];
            table[j] = temp;
        }
    }

    table[right] = table[i + 1];
    table[i + 1] = pivot;

    return i + 1;
}

void IdNameTable::quickSortByName(int left, int right) {
    if (right - left < 10) {
        for (int i = left + 1; i <= right; i++) {
            IdName* key = table[i];
            int j = i - 1;
            while (j >= left && stringLess(key->name, table[j]->name)) {
                table[j + 1] = table[j];
                j--;
            }
            table[j + 1] = key;
        }
        return;
    }

    if (left < right) {
        int pivotIndex = partitionByName(left, right);
        quickSortByName(left, pivotIndex - 1);
        quickSortByName(pivotIndex + 1, right);
    }
}

void IdNameTable::sortByName() {
    if (count <= 1) {
        isSortedByName = true;
        return;
    }
    quickSortByName(0, count - 1);
    isSortedByName = true;
    isSortedById = false;
}

int IdNameTable::binarySearchById(int id) const {
    if (!isSortedById) return -1;

    int left = 0;
    int right = count - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (table[mid]->id == id) {
            return mid;
        }
        if (table[mid]->id < id) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}

const char* IdNameTable::getNameById(int id) const {
    int index = binarySearchById(id);
    if (index != -1) {
        return table[index]->name;
    }
    return 0;
}

int IdNameTable::binarySearchByName(const char* name) const {
    if (!isSortedByName) return -1;

    int left = 0;
    int right = count - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (stringEqual(table[mid]->name, name)) {
            return mid;
        }
        if (stringLess(table[mid]->name, name)) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}

int IdNameTable::getIdByName(const char* name) const {
    int index = binarySearchByName(name);
    if (index != -1) {
        return table[index]->id;
    }
    return -1;
}

IdName* IdNameTable::getElement(int index) const {
    if (index >= 0 && index < count) {
        return table[index];
    }
    return 0;
}